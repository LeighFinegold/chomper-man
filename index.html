<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chomper Man</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: linear-gradient(135deg, #1a1a2e, #0f3460);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }

    /* â”€â”€ UPLOAD SCREEN â”€â”€ */
    #uploadScreen {
      text-align: center;
      color: #fff;
      padding: 40px;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 20px;
      width: 420px;
      max-width: 95vw;
    }

    #uploadScreen h1 {
      font-size: 2.6em;
      color: #ffd700;
      text-shadow: 0 0 20px rgba(255,215,0,0.4);
      margin-bottom: 4px;
    }

    #uploadScreen .subtitle { color: #aaa; font-size: 1em; margin-bottom: 22px; }

    .upload-area {
      border: 2px dashed rgba(255,215,0,0.5);
      border-radius: 12px;
      padding: 26px 16px;
      cursor: pointer;
      transition: all 0.2s;
      background: rgba(255,215,0,0.04);
      margin-bottom: 12px;
    }
    .upload-area:hover { border-color: #ffd700; background: rgba(255,215,0,0.1); }
    .upload-area p { color: #ddd; font-size: 1.05em; }
    .upload-area .hint { color: #888; font-size: 0.85em; margin-top: 5px; }

    /* â”€â”€ TWO-SLOT UPLOAD GRID â”€â”€ */
    .upload-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 8px; }
    .upload-slot { display: flex; flex-direction: column; align-items: center; }
    .slot-label { color: #ffd700; font-size: 0.9em; font-weight: bold; margin-bottom: 6px; }
    .upload-slot .upload-area { padding: 16px 8px; margin-bottom: 0; width: 100%; }
    .upload-slot .upload-area p { font-size: 0.88em; }
    .slot-preview {
      width: 78px; height: 78px;
      border-radius: 50%; object-fit: cover;
      border: 2px solid #ffd700;
      box-shadow: 0 0 10px rgba(255,215,0,0.3);
      margin-top: 8px;
    }
    .slot-processing { color: #aaa; font-size: 0.8em; margin-top: 6px; display: none; }
    .bg-removal-note { color: #777; font-size: 0.78em; margin: 4px 0 10px; }

    .instructions {
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      padding: 11px 15px;
      margin: 12px 0;
      font-size: 0.9em;
      color: #ccc;
      text-align: left;
      line-height: 1.9;
    }

    #startBtn {
      background: linear-gradient(135deg, #ffd700, #ff8c00);
      color: #1a1a2e;
      border: none;
      padding: 12px 36px;
      font-size: 1.2em;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 14px rgba(255,200,0,0.3);
      margin-top: 6px;
    }
    #startBtn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255,200,0,0.5); }
    #startBtn:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; }

    /* â”€â”€ DIFFICULTY SELECTOR â”€â”€ */
    .difficulty-wrap { margin: 12px 0; }
    .difficulty-wrap > span { display: block; color: #bbb; font-size: 0.88em; margin-bottom: 8px; }
    .difficulty-btns { display: flex; gap: 8px; }
    .diff-btn {
      flex: 1;
      padding: 8px 4px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.05);
      color: #ccc;
      cursor: pointer;
      font-size: 0.88em;
      transition: all 0.2s;
    }
    .diff-btn:hover { background: rgba(255,255,255,0.12); }
    .diff-btn.selected {
      border-color: #ffd700;
      background: rgba(255,215,0,0.14);
      color: #ffd700;
      font-weight: bold;
    }

    /* â”€â”€ GAME CONTAINER â”€â”€ */
    #gameWrap { display: none; position: relative; }
    #gameCanvas { display: block; max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 8px 30px rgba(0,0,0,0.5); }

    /* On-screen directional buttons */
    #touchControls {
      position: absolute;
      right: 14px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .touchBtn {
      width: 52px; height: 52px;
      border-radius: 50%;
      background: rgba(255,255,255,0.16);
      border: 2px solid rgba(255,255,255,0.32);
      color: #fff;
      font-size: 1.4em;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      user-select: none; -webkit-user-select: none;
      touch-action: none;
    }
    .touchBtn:active { background: rgba(255,255,255,0.35); }

    /* â”€â”€ GAME OVER OVERLAY â”€â”€ */
    #gameOverOverlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      backdrop-filter: blur(4px);
      justify-content: center;
      align-items: center;
      z-index: 200;
    }
    #gameOverOverlay.show { display: flex; }

    .go-box {
      background: rgba(8,8,25,0.96);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 20px;
      padding: 38px 52px;
      text-align: center;
      color: #fff;
    }
    .go-box h2 { font-size: 2.3em; color: #ff4444; margin-bottom: 6px; }
    .go-score  { font-size: 1.55em; color: #ffd700; margin: 10px 0 3px; }
    .go-best   { font-size: 0.95em; color: #aaa; margin-bottom: 20px; }
    .go-btns   { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }

    .btn-primary {
      background: linear-gradient(135deg, #ffd700, #ff8c00);
      color: #1a1a2e; border: none;
      padding: 11px 26px; font-size: 1em; font-weight: bold;
      border-radius: 20px; cursor: pointer; transition: all 0.2s;
    }
    .btn-primary:hover { transform: translateY(-2px); }

    .btn-secondary {
      background: rgba(255,255,255,0.1); color: #ddd;
      border: 1px solid rgba(255,255,255,0.25);
      padding: 11px 26px; font-size: 1em;
      border-radius: 20px; cursor: pointer; transition: all 0.2s;
    }
    .btn-secondary:hover { background: rgba(255,255,255,0.2); }
  </style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• UPLOAD SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="uploadScreen">
  <h1>ğŸ˜„ Chomper Man</h1>
  <p class="subtitle">The face-chomping side-scroller!</p>

  <div class="upload-grid">
    <div class="upload-slot">
      <span class="slot-label">ğŸ˜„ Mouth Open</span>
      <div class="upload-area" id="uploadAreaOpen">
        <p>ğŸ“¸ Upload photo</p>
        <p class="hint">With mouth open</p>
      </div>
      <input type="file" id="imageUploadOpen" accept="image/*" style="display:none">
      <p class="slot-processing" id="processingOpen">ğŸ¤– Processingâ€¦</p>
      <img class="slot-preview" id="previewOpen" src="" alt="Mouth open preview" style="display:none">
    </div>
    <div class="upload-slot">
      <span class="slot-label">ğŸ˜ Mouth Closed</span>
      <div class="upload-area" id="uploadAreaClosed">
        <p>ğŸ“¸ Upload photo</p>
        <p class="hint">With mouth closed</p>
      </div>
      <input type="file" id="imageUploadClosed" accept="image/*" style="display:none">
      <p class="slot-processing" id="processingClosed">ğŸ¤– Processingâ€¦</p>
      <img class="slot-preview" id="previewClosed" src="" alt="Mouth closed preview" style="display:none">
    </div>
  </div>
  <p class="bg-removal-note">ğŸ¤– Background removed automatically using AI</p>

  <div class="instructions">
    <div>â¬†ï¸ <b>Up Arrow / W</b> &mdash; Move up</div>
    <div>â¬‡ï¸ <b>Down Arrow / S</b> &mdash; Move down</div>
    <div>ğŸ“± <b>Touch top / bottom</b> of screen to move</div>
    <div>ğŸª™ Collect gold coins to earn points</div>
    <div>ğŸ§± Dodge the green pipes â€” or it's game over!</div>
  </div>

  <div class="difficulty-wrap">
    <span>ğŸ® Select Difficulty:</span>
    <div class="difficulty-btns">
      <button class="diff-btn" data-speed="1.5" aria-label="Easy difficulty">ğŸŸ¢ Easy</button>
      <button class="diff-btn selected" data-speed="2.5" aria-label="Medium difficulty">ğŸŸ¡ Medium</button>
      <button class="diff-btn" data-speed="4.0" aria-label="Hard difficulty">ğŸ”´ Hard</button>
    </div>
  </div>

  <button id="startBtn" disabled>â–¶ Start Game</button>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="gameWrap">
  <canvas id="gameCanvas"></canvas>
  <div id="touchControls">
    <button class="touchBtn" id="upBtn">â–²</button>
    <button class="touchBtn" id="downBtn">â–¼</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME OVER â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="gameOverOverlay">
  <div class="go-box">
    <h2>ğŸ’€ Game Over!</h2>
    <div class="go-score">Score: <span id="goScore">0</span></div>
    <div class="go-best">Best: <span id="goBest">0</span></div>
    <div class="go-btns">
      <button class="btn-primary"   id="restartBtn">ğŸ”„ Play Again</button>
      <button class="btn-secondary" id="newFaceBtn">ğŸ“¸ Change Face</button>
    </div>
  </div>
</div>

<script>
'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CANVAS_W   = 800;
const CANVAS_H   = 450;
const GROUND_Y   = 400;  // y-coordinate of ground surface
const CEIL_Y     = 40;   // y-coordinate of ceiling
const PLAYER_X   = 140;  // fixed horizontal position of player centre
const PLAYER_R   = 38;   // player (face circle) radius in px
const MOVE_SPEED = 5;    // vertical px per frame when key held

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CANVAS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('gameCanvas');
const ctx    = canvas.getContext('2d');
canvas.width  = CANVAS_W;
canvas.height = CANVAS_H;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let playerImgOpen   = null;  // HTMLImageElement â€” mouth open
let playerImgClosed = null;  // HTMLImageElement â€” mouth closed
let playerY    = 0;      // player centre Y
let score      = 0;
let bestScore  = 0;
let frame      = 0;
let speed      = 2.5;    // world scroll speed (px/frame)
let nextPipeAt = 130;    // frame number when next pipe pair spawns
let running    = false;
let animId     = null;

const keys      = {};
let obstacles   = [];    // { x, y, w, h }
let coins       = [];    // { x, y, r, spin, collected }
let particles   = [];    // { x, y, vx, vy, life, maxLife }
let floatTexts  = [];    // { x, y, life, maxLife }
let clouds      = [];    // { x, y, scale }
let bgStripe    = 0;     // ground stripe scroll offset

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI REFS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const uploadScreen    = document.getElementById('uploadScreen');
const gameWrap        = document.getElementById('gameWrap');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const startBtn        = document.getElementById('startBtn');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKGROUND REMOVAL (lazy-loaded AI library)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const _bgRemovalPromise = import('https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.4.5/dist/index.browser.mjs')
  .then(m => m.removeBackground)
  .catch(() => null);

function readFileAsDataURL(file) {
  return new Promise(resolve => {
    const reader = new FileReader();
    reader.onload = ev => resolve(ev.target.result);
    reader.readAsDataURL(file);
  });
}

async function applyBgRemoval(file) {
  const removeBackground = await _bgRemovalPromise;
  if (!removeBackground) return null;
  try {
    const blob = await removeBackground(file);
    return URL.createObjectURL(blob);
  } catch (e) {
    console.warn('Background removal failed, using original image:', e);
    return null;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UPLOAD / PREVIEW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateStartBtn() {
  startBtn.disabled = !(playerImgOpen || playerImgClosed);
}

async function loadImageSlot(slot, file) {
  if (!file || !file.type.startsWith('image/')) return;

  const isOpen      = slot === 'open';
  const processingEl = document.getElementById(isOpen ? 'processingOpen' : 'processingClosed');
  const previewEl    = document.getElementById(isOpen ? 'previewOpen'    : 'previewClosed');
  const uploadArea   = document.getElementById(isOpen ? 'uploadAreaOpen' : 'uploadAreaClosed');

  // Show processing state
  processingEl.style.display = 'block';
  previewEl.style.display    = 'none';
  uploadArea.style.opacity   = '0.5';

  // Try AI background removal; fall back to raw data URL
  let src = await applyBgRemoval(file);
  if (!src) {
    src = await readFileAsDataURL(file);
  }

  const img   = new Image();
  img.src     = src;
  img.onload  = () => {
    if (isOpen) playerImgOpen   = img;
    else        playerImgClosed = img;
    previewEl.src              = src;
    previewEl.style.display    = 'block';
    processingEl.style.display = 'none';
    uploadArea.style.opacity   = '1';
    updateStartBtn();
  };
}

function setupSlot(slot) {
  const isOpen    = slot === 'open';
  const areaId    = isOpen ? 'uploadAreaOpen'   : 'uploadAreaClosed';
  const inputId   = isOpen ? 'imageUploadOpen'  : 'imageUploadClosed';
  const area      = document.getElementById(areaId);
  const input     = document.getElementById(inputId);

  area.addEventListener('click', () => input.click());
  input.addEventListener('change', e => loadImageSlot(slot, e.target.files[0]));

  area.addEventListener('dragover', e => {
    e.preventDefault();
    area.style.borderColor = '#ffd700';
  });
  area.addEventListener('dragleave', () => { area.style.borderColor = ''; });
  area.addEventListener('drop', e => {
    e.preventDefault();
    area.style.borderColor = '';
    loadImageSlot(slot, e.dataTransfer.files[0]);
  });
}

setupSlot('open');
setupSlot('closed');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIFFICULTY SELECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let selectedSpeed = 2.5;  // default: Medium

document.querySelectorAll('.diff-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('selected'));
    btn.classList.add('selected');
    selectedSpeed = parseFloat(btn.dataset.speed);
  });
});

// (removed: loadImageFile â€” replaced by loadImageSlot above)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SCREEN TRANSITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
startBtn.addEventListener('click', () => {
  uploadScreen.style.display = 'none';
  gameWrap.style.display     = 'block';
  initGame();
});

document.getElementById('restartBtn').addEventListener('click', () => {
  gameOverOverlay.classList.remove('show');
  initGame();
});

document.getElementById('newFaceBtn').addEventListener('click', () => {
  gameOverOverlay.classList.remove('show');
  running = false;
  gameWrap.style.display     = 'none';
  uploadScreen.style.display = 'block';
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT â€” KEYBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) {
    e.preventDefault();
  }
});
document.addEventListener('keyup', e => { keys[e.key] = false; });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT â€” ON-SCREEN BUTTONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function addHoldEvents(btn, keyName) {
  btn.addEventListener('pointerdown',  e => { e.preventDefault(); keys[keyName] = true;  });
  btn.addEventListener('pointerup',    e => { e.preventDefault(); keys[keyName] = false; });
  btn.addEventListener('pointerleave', ()  => { keys[keyName] = false; });
}
addHoldEvents(document.getElementById('upBtn'),   'ArrowUp');
addHoldEvents(document.getElementById('downBtn'), 'ArrowDown');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT â€” CANVAS TOUCH (touch upper half = up, lower half = down)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function handleCanvasTouch(e) {
  e.preventDefault();
  if (!e.touches.length) return;
  const rect  = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  const relY  = touch.clientY - rect.top;
  keys['ArrowUp']   = relY < rect.height / 2;
  keys['ArrowDown'] = relY >= rect.height / 2;
}
canvas.addEventListener('touchstart', handleCanvasTouch, { passive: false });
canvas.addEventListener('touchmove',  handleCanvasTouch, { passive: false });
canvas.addEventListener('touchend',   () => {
  keys['ArrowUp']   = false;
  keys['ArrowDown'] = false;
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initGame() {
  score      = 0;
  frame      = 0;
  speed      = selectedSpeed;
  nextPipeAt = 130;
  playerY    = (CEIL_Y + GROUND_Y) / 2;
  obstacles  = [];
  coins      = [];
  particles  = [];
  floatTexts = [];
  bgStripe   = 0;

  clouds = Array.from({ length: 5 }, (_, i) => ({
    x: i * 180 + 60,
    y: 38 + Math.random() * 65,
    scale: 0.65 + Math.random() * 0.55,
  }));

  if (animId) cancelAnimationFrame(animId);
  running = true;
  loop();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SPAWNING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function spawnPipePair() {
  // Gap between pipes narrows as game progresses
  const GAP    = Math.max(110, 155 - Math.floor(frame / 120));
  const usable = GROUND_Y - CEIL_Y - GAP;
  const gapTop = CEIL_Y + Math.random() * usable;
  const gapBot = gapTop + GAP;
  const x      = CANVAS_W + 30;
  const W      = 58;

  // Top pipe
  if (gapTop - CEIL_Y > 5) {
    obstacles.push({ x, y: CEIL_Y, w: W, h: gapTop - CEIL_Y });
  }
  // Bottom pipe
  if (GROUND_Y - gapBot > 5) {
    obstacles.push({ x, y: gapBot, w: W, h: GROUND_Y - gapBot });
  }
  // Coin centred in the gap
  if (Math.random() > 0.15) {
    coins.push({
      x: x + W / 2 + 55,
      y: gapTop + GAP / 2,
      r: 15,
      spin: Math.random() * Math.PI,
      collected: false,
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLISION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function hitTest() {
  // Circle vs AABB (shrink radius slightly for forgiveness)
  const sr = PLAYER_R - 6;
  for (const o of obstacles) {
    const nearX = Math.max(o.x, Math.min(PLAYER_X, o.x + o.w));
    const nearY = Math.max(o.y, Math.min(playerY,  o.y + o.h));
    const dx = PLAYER_X - nearX;
    const dy = playerY  - nearY;
    if (dx * dx + dy * dy < sr * sr) return true;
  }
  return false;
}

function collectCoins() {
  for (const c of coins) {
    if (c.collected) continue;
    const dx = PLAYER_X - c.x;
    const dy = playerY  - c.y;
    if (dx * dx + dy * dy < (PLAYER_R + c.r - 4) ** 2) {
      c.collected = true;
      score++;
      burst(c.x, c.y);
      floatTexts.push({ x: c.x, y: c.y, life: 45, maxLife: 45 });
    }
  }
}

function burst(x, y) {
  for (let i = 0; i < 10; i++) {
    const a = (Math.PI * 2 * i) / 10;
    particles.push({
      x, y,
      vx: Math.cos(a) * (2 + Math.random() * 2),
      vy: Math.sin(a) * (2 + Math.random() * 2),
      life: 30, maxLife: 30,
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function update() {
  // Move player (clamped to play area)
  if (keys['ArrowUp'] || keys['w'] || keys['W']) {
    playerY = Math.max(CEIL_Y + PLAYER_R, playerY - MOVE_SPEED);
  }
  if (keys['ArrowDown'] || keys['s'] || keys['S']) {
    playerY = Math.min(GROUND_Y - PLAYER_R, playerY + MOVE_SPEED);
  }

  // Ground stripe scroll
  bgStripe = (bgStripe + speed * 0.4) % 40;

  // Clouds parallax
  for (const cl of clouds) {
    cl.x -= speed * 0.25;
    if (cl.x < -200) { cl.x = CANVAS_W + 60; cl.y = 32 + Math.random() * 68; }
  }

  // Obstacles
  for (const o of obstacles) o.x -= speed;
  obstacles = obstacles.filter(o => o.x + o.w > -10);

  // Coins
  for (const c of coins) { c.x -= speed; c.spin += 0.07; }
  coins = coins.filter(c => c.x > -40);

  // Particles
  for (const p of particles) { p.x += p.vx; p.y += p.vy; p.life--; }
  particles = particles.filter(p => p.life > 0);

  // Floating "+1" texts
  for (const t of floatTexts) t.life--;
  floatTexts = floatTexts.filter(t => t.life > 0);

  // Spawn pipe pairs
  if (frame >= nextPipeAt) {
    spawnPipePair();
    nextPipeAt = frame + Math.max(60, Math.round(325 / speed));
  }

  // Speed ramp
  if (frame > 0 && frame % 400 === 0) {
    speed = Math.min(7, speed + 0.25);
  }

  frame++;
  collectCoins();
  if (hitTest()) endGame();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW â€” BACKGROUND
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawBg() {
  // Sky gradient
  const sky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  sky.addColorStop(0, '#5fa8d3');
  sky.addColorStop(1, '#c9e8f5');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, CANVAS_W, GROUND_Y);

  // Clouds
  ctx.fillStyle = 'rgba(255,255,255,0.82)';
  for (const cl of clouds) drawCloud(cl.x, cl.y, cl.scale);

  // Ground
  const gnd = ctx.createLinearGradient(0, GROUND_Y, 0, CANVAS_H);
  gnd.addColorStop(0,    '#5a9944');
  gnd.addColorStop(0.25, '#4a8835');
  gnd.addColorStop(1,    '#2e6020');
  ctx.fillStyle = gnd;
  ctx.fillRect(0, GROUND_Y, CANVAS_W, CANVAS_H - GROUND_Y);

  // Ground top highlight strip
  ctx.fillStyle = '#72b84a';
  ctx.fillRect(0, GROUND_Y, CANVAS_W, 7);

  // Scrolling diagonal stripes on ground
  ctx.save();
  ctx.strokeStyle = 'rgba(0,0,0,0.08)';
  ctx.lineWidth = 2;
  const sg = 40;
  for (let i = -2; i < CANVAS_W / sg + 2; i++) {
    const sx = i * sg - bgStripe;
    ctx.beginPath();
    ctx.moveTo(sx, GROUND_Y);
    ctx.lineTo(sx - 25, CANVAS_H);
    ctx.stroke();
  }
  ctx.restore();
}

function drawCloud(x, y, scale) {
  const w = 100 * scale, h = 36 * scale;
  ctx.save();
  ctx.translate(x, y);
  ctx.beginPath();
  ctx.ellipse(w * 0.50, h * 0.55, w * 0.50, h * 0.42, 0, 0, Math.PI * 2);
  ctx.ellipse(w * 0.28, h * 0.65, w * 0.30, h * 0.48, 0, 0, Math.PI * 2);
  ctx.ellipse(w * 0.72, h * 0.65, w * 0.26, h * 0.40, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW â€” PIPES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawPipes() {
  for (const o of obstacles) {
    // Body gradient
    const g = ctx.createLinearGradient(o.x, 0, o.x + o.w, 0);
    g.addColorStop(0,    '#2d6e2d');
    g.addColorStop(0.25, '#4cb84c');
    g.addColorStop(0.65, '#3da83d');
    g.addColorStop(1,    '#1e5e1e');
    ctx.fillStyle = g;
    ctx.fillRect(o.x, o.y, o.w, o.h);

    // Cap at the open end
    const capH = 22, capW = o.w + 12, capX = o.x - 6;
    const capY = (o.y === CEIL_Y) ? o.y + o.h - capH : o.y;
    const cg = ctx.createLinearGradient(capX, 0, capX + capW, 0);
    cg.addColorStop(0,    '#1e5e1e');
    cg.addColorStop(0.30, '#4cb84c');
    cg.addColorStop(0.70, '#3da83d');
    cg.addColorStop(1,    '#1e5e1e');
    ctx.fillStyle = cg;
    ctx.fillRect(capX, capY, capW, capH);

    // Outlines
    ctx.strokeStyle = '#154a15';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(o.x, o.y, o.w, o.h);
    ctx.strokeRect(capX, capY, capW, capH);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW â€” COINS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawCoins() {
  for (const c of coins) {
    if (c.collected) continue;
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.scale(Math.abs(Math.cos(c.spin)), 1);   // spinning effect

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.beginPath();
    ctx.ellipse(2, 3, c.r, c.r, 0, 0, Math.PI * 2);
    ctx.fill();

    // Body
    const cg = ctx.createRadialGradient(-c.r * 0.3, -c.r * 0.3, c.r * 0.1, 0, 0, c.r);
    cg.addColorStop(0,   '#ffe566');
    cg.addColorStop(0.5, '#ffd700');
    cg.addColorStop(1,   '#c8a000');
    ctx.fillStyle = cg;
    ctx.beginPath();
    ctx.arc(0, 0, c.r, 0, Math.PI * 2);
    ctx.fill();

    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.36)';
    ctx.beginPath();
    ctx.ellipse(-c.r * 0.22, -c.r * 0.28, c.r * 0.32, c.r * 0.20, -0.4, 0, Math.PI * 2);
    ctx.fill();

    // Dollar sign
    ctx.fillStyle = '#9a7800';
    ctx.font = `bold ${c.r}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('$', 0, 1);

    ctx.restore();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW â€” PLAYER (image swap: mouth-open near coins, mouth-closed otherwise)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Draw img cropped to fill the rect (x,y,w,h) â€” object-fit: cover behaviour.
 */
function drawImgCover(img, x, y, w, h) {
  const aspectRatio       = img.naturalWidth / img.naturalHeight;
  const targetAspectRatio = w / h;
  let sx, sy, sw, sh;
  if (aspectRatio > targetAspectRatio) {
    sh = img.naturalHeight; sw = sh * targetAspectRatio;
    sx = (img.naturalWidth  - sw) / 2; sy = 0;
  } else {
    sw = img.naturalWidth; sh = sw / targetAspectRatio;
    sx = 0; sy = (img.naturalHeight - sh) / 2;
  }
  ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h);
}

function drawPlayer() {
  const cx   = PLAYER_X;
  const cy   = playerY;
  const r    = PLAYER_R;
  const diam = r * 2;
  const x    = cx - r;
  const y    = cy - r;

  // Drop shadow on ground
  ctx.fillStyle = 'rgba(0,0,0,0.20)';
  ctx.beginPath();
  ctx.ellipse(cx, GROUND_Y - 1, r * 0.65, 8, 0, 0, Math.PI * 2);
  ctx.fill();

  // Show mouth-open image when a coin is within 160 px, else mouth-closed
  let nearCoin = false;
  for (const c of coins) {
    if (c.collected) continue;
    const dx = PLAYER_X - c.x;
    const dy = playerY  - c.y;
    if (dx * dx + dy * dy < 160 * 160) { nearCoin = true; break; }
  }
  const img = nearCoin
    ? (playerImgOpen  || playerImgClosed)
    : (playerImgClosed || playerImgOpen);

  if (img && img.complete && img.naturalWidth > 0) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.clip();
    drawImgCover(img, x, y, diam, diam);
    ctx.restore();
  } else {
    // Fallback: simple smiley face
    ctx.save();
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.clip();
    ctx.fillStyle = '#f5c57a';
    ctx.fillRect(x, y, diam, diam);
    ctx.fillStyle = '#3a2a1a';
    ctx.beginPath(); ctx.arc(cx - r * 0.30, cy - r * 0.14, 5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + r * 0.30, cy - r * 0.14, 5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#8b3a3a';
    ctx.beginPath();
    if (nearCoin) {
      ctx.ellipse(cx, cy + r * 0.22, r * 0.38, r * 0.22, 0, 0, Math.PI * 2);
    } else {
      ctx.arc(cx, cy + r * 0.18, r * 0.30, 0, Math.PI);
    }
    ctx.fill();
    ctx.restore();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW â€” PARTICLES & FLOATING TEXTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawParticles() {
  for (const p of particles) {
    const a = p.life / p.maxLife;
    ctx.fillStyle = `rgba(255,215,0,${a})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 5 * a, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawFloatTexts() {
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  ctx.font         = 'bold 20px Arial';
  for (const t of floatTexts) {
    const a  = t.life / t.maxLife;
    const dy = (1 - a) * 32;
    ctx.fillStyle = `rgba(255,215,0,${a})`;
    ctx.fillText('+1', t.x, t.y - dy);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAW â€” HUD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawHUD() {
  // Score
  ctx.fillStyle = 'rgba(0,0,0,0.38)';
  rrect(CANVAS_W - 128, 10, 118, 38, 8);
  ctx.fill();
  ctx.fillStyle      = '#ffd700';
  ctx.font           = 'bold 21px Arial';
  ctx.textAlign      = 'right';
  ctx.textBaseline   = 'middle';
  ctx.fillText(`ğŸª™ ${score}`, CANVAS_W - 14, 29);

  // Speed indicator
  ctx.fillStyle = 'rgba(0,0,0,0.28)';
  rrect(10, 10, 118, 28, 6);
  ctx.fill();
  ctx.fillStyle    = '#ddd';
  ctx.font         = '13px Arial';
  ctx.textAlign    = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillText(`Speed Ã—${speed.toFixed(1)}`, 18, 24);
}

/** Utility: define a rounded rectangle path (call fill/stroke after). */
function rrect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y,   x + w, y + r);
  ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function loop() {
  if (!running) return;
  update();
  ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
  drawBg();
  drawPipes();
  drawCoins();
  drawPlayer();
  drawParticles();
  drawFloatTexts();
  drawHUD();
  animId = requestAnimationFrame(loop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME OVER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function endGame() {
  running = false;
  if (score > bestScore) bestScore = score;
  document.getElementById('goScore').textContent = score;
  document.getElementById('goBest').textContent  = bestScore;
  gameOverOverlay.classList.add('show');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BOOTSTRAP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
uploadScreen.style.display = 'block';
gameWrap.style.display     = 'none';
gameOverOverlay.classList.remove('show');
</script>
</body>
</html>
